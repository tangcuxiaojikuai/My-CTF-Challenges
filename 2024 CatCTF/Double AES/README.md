## Double AES

+ Difficulty：Easy
+ Solved：

<br/>

## Description

Bear accidentally got two ciphertexts of the same AES encryptor!

<br/>

## Hint

+ 先把两部分密文分离开

+ 尝试找出密文长度与flag长度的关系式

+ AES CTR nonce复用

+ 熊突然发现，自己好像能用二部分密文的第一个分组算出某个东西！

<br/>

## Solution

题目基于AES的CTR模式，用flag的前16个字节当作密钥，用"CatCTF2024"当作iv，然后分别加密：

+ 整体pad到十六字节整数倍的flag串
+ 逐字节pad到十六字节整数倍的flag串

题目将两个密文连接起来给出，要求还原flag。

首先我们要把两个密文分离开才行，为此我们需要确定flag长度，而确定flag长度的依据是密文长度。由于有pad的存在，密文以16字节为一组，其分组数量为：
$$
\lceil\frac{len(flag)}{16}\rceil + len(flag)
$$

> 这里其实并不准确，因为如果flag长度恰为16的整数倍的话pad会多一个分组

我们可以小范围遍历一下flag可能的字节数，判断其满不满足上面的式子，就可以确定下来flag的长度为49，从而分离两部分密文。

分离密文之后下一步就是恢复flag，为此需要了解一下CTR加密模式，该模式加密步骤是：

+ 加密当前Counter
+ 将加密的Counter与当前分组明文异或，得到当前分组密文
+ Counter加一，用于下一分组加密

而由于加密两部分密文的密钥和起始Counter都一样，所以说他们异或的是同一个密钥流。而我们知道flag头，也就知道了第二部分密文第一个分组的明文是：

```python
b"c" + b"\x0f"*15
```

将该明文与第一组密文异或就得到了第一组的密钥流，再与第一部分密文的第一组异或就得到了明文，而这个明文是key，就可以解得所有密文了。

exp：

```python
from Crypto.Cipher import AES
from pwn import xor

c = b'\xbf\xa2\xe1P\x10\xcf4\x1a\x82\xd7M\xda\xd7?W\x8e!\xc2\xe0S\x93y\xbf\xaf\xe0l\xfdM\x0f\xb7\xac\xc0\x17\xd8\xa0+E\x97z\x95izN^\x84]yd\xdf\x8f\xcb\'\x17\x16m\xb0/5Z\xf6O\x97D\x03\xbf\xcc\x9a<k\xa6@@\xb8\xb1,\xb2\x87h\x17\xd3\x1f\x8d\x818\xc34\xc2\xd5\xd8P\xb4rr\xfb\xc6\x90!\xe6\x9fG\x01\xeb*\xd8\x1f*#\x1d\xc4\x11\x1dX\xc1\x8f\xcb\'\x17\x16m\xb0/5Z\xf6O\x97D\x03^\xa1E\t\x87\x90\xc9\xc5\x95{0K\x93g\xf8\r7\x9af\xa4X\x81\x0bF\x08\xf9\xe3\x01\xdf\'\xf7\x03I]\xb4T\x16H4(|\xb4 \xd3\x1f\x8b\xbe!\xefM\x11\x9cw\t$\t\x97\xc8\xf9\xe4\xcf\xe9\x91\xfa\x968s\xf8=\xbd\xf2k\xe6\x1f\xf6\xbeS\xcfH\xd6\x89_\xea\xc8\x7f8\xef?\xab\x07y\xdf\xc1\xf4\x1c\xb3\xe3\x18\x96\xbbR?\xe8\xfe\xc5[p\xe9\xa3\x91\xc3\xce\x86\xb2\xbc\xe4\t)J\x04\x86GC_y\xf7\x1b\xeb\xd7\x1c\x9al\x94\x93Tm\x99\xaf,J\x97q\x13\xaf\xb3\xd0\xc6]\x1d\n-\xfc\xae\xde"@\xff\xa6F\x96\xa5p\x1bZK\x82\x07\xe4XQh\xfa\x02\xcf\x06\x81\xbe\x12z\xe1V\xa1\xab\x7f+\xf9l\xea\x02\x1d\x91\xadq\xd9\x93\xb5\x1c\x8a\x8b\xf5\xcb\x8e\x0b\xbf\x17qw\xecR\xf7\xef\xe8\x11\x96\xc2\x85\xd0.\x9f&\x04\x7f\xeb:7\xbd\xaa\xb2|\x90\x16\x93\x81\xc1\x1b>h\x80n\xd3\xe4H7\xa8h\x9cp\xf8Z\xd9\xe1\xddfO\xac\x1eK\x90O\x12\xf4h=\xf1^\xc3\x01Vs\xea\xe6\xa1\xaeg\xb6\'f\xf6\xc8.J2\xc9\x96\x96\xd2\x9b\x17\xc8\x97\x05IX#\xff?\xae\xd9\x18\x86^zD;\xb1\xa1\xb1?\x11\x1d\xb9a\xe9\xff+\x16\xbc\x9b\xb2\xe5\x1d\xa0\xb8(]<aX\xb3\xc3\xfc\x1aU"\xfb\x1c\x80T\x11.\xc2\xa5A\xb4\xa8\xcetj\x91J\xdd\xc7B\xcc v\xbb\x8e\xc5DR#\x89\xb3m\xb2\xbc\xfa\xb0\xd7\xe8\x99\xf8\xa3\xc8\x00\xf2W\xafT\x92\x86\xfd\xf4=\x1a\x84)\xd3\x12\x16\xb0\xf7\x00\xfd\x18\xaf3\xe9\xc1,\xe1u\xb6\xc2z\xffbu1\x9f\xe1\x16\xb0b\x1f\xea\x00\n\xa6\xc7\r \xde\xcd\xf7~V\x19\'\x05\xc2\xcd>owY\xe9\xb2\xb4a\'\xb7\xf4+\x9d\x83\xd3\xd3`*]>\xea|\xb96\'\xd7in\x9a\x1d\xf1\x92\x86\x19\xb3Q#E\x99\xe9\xe0\x902~V\x94L\xe5\xb6\xbb\xdc\x16p\xce|\xd6%\xb7\xac\xb25\x92{%\xea\xa2\x0b\x0e\')zv\x18\xcc-A\x0e\x88\xb3\xfd\x07\xe4\x8d\xe1E~\x97DWe\xf9.\xd2Q\xb8a\xa2\'\xccS\xa6j\x8e\xcd\xb0\x80\x19\x8f\xa3\x98\xf0&Bq\x98\xe6dz\xc6V\x0e*\x8b6t\x8fF\xe6\xcc\x98P\xbe\xb5\xd0\x86\xd4\x17\xb3Iq\x08\x12<\xf6\xda\x7f\x8da\x8c\xe87\x02D\\@\x928\xcb\xc1O\x0fd\xe0\xfa\xa2\x8a;&\x14\x16g\x8f\xf6Ik\xae\x8fl,\xe0\xa1b\xfej\xdc\xc7$\x99\x95\xed\x0c$\x15\xa5n\xdeG\x02\x18&t"\xf8D\xb7T\xad=\x9cN`\x1e\xc3\xa3\x88\xde\x04[\\\x04)\x00\xcb\xb4+\x84T\xc5\x95\x04\t$\x1c\xa3sc\x17pppi\xd0\'\x1f3\x1d\xac\xf1\x98qU \x85\x01\x94\x80\x98\ri\x82\x1c\xf1nX\xa2&e\xd2B\x90\xc5\xee\x0bf_\xc6\xb9\xbaf\x1c\x11\x9c\x04\x07\xcc\x1d#'

if(0):
    for length in range(10,100):
        if((length//16)+1 + length == len(c)//16):
            print(length)

#length = 49 -> padding to 64
c1 = c[:64]
c2 = c[64:]
iv = b"CatCTF2024"
prefix = b"c"+b"\x0f"*15
key = xor(c1[:16], xor(prefix,c2[:16]))

flag = AES.new(key=key,nonce=iv,mode=AES.MODE_CTR).decrypt(c1)
print(flag)


#catctf{U5ing_XOR_@nd_Bru73F0rCe_B10cKs_By_bLOCk3}
```
