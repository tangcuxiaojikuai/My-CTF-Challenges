## easy_factor2

+ Difficulty：Easy

## Solution

首先，题目生成两个1024bit的素数p、q，保证其高350位相等。并且给出如下式子的低300位：
$$
(p^q + q^p) \quad(mod\;n)
$$
其实这个式子在以前的一些比赛已经出现过，他其实就是p+q，这是因为比如对于$c = p^q \quad(mod\;n)$，用同余性质就可以写作：
$$
c_p = p^q = 0 \quad(mod\;p)
$$

$$
c_q = p^q = p \quad(mod\;q)
$$

然后将两者crt起来就得到c其实在模n下就是p了。对于q^p模n也同理，因此整个式子其实就是p+q。

所以现在我们拥有的就是：

+ p和q高350位相同
+ p+q的低300位

而p、q高位相同就容易想到是要用费马分解，然而直接分解是不行的，必须把第二个信息同时利用上。回顾一下费马分解的原理：

> 由于n可以写成一个平方差的形式：$n = pq = (\frac{p+q}{2})^2 - (\frac{p-q}{2})^2$
>
> 那么令$a = \frac{p+q}{2},b = \frac{p-q}{2}$，n也就可以写为$n = (a+b)(a-b)$
>
> 而费马分解的核心思想就是找到这样的a，他从$a=\sqrt{n}$开始，逐步增加a，一直到发现$a^2-n$是个平方数，就找到了正确的a、b，n也就成功分解了。

回顾一下思路后可以发现，费马分解所需要的时间，依赖于$\frac{p+q}{2}$与$\sqrt{n}$的差值。而p、q高位相等之所以利于费马分解，就是因为p、q高位相等会使得$\frac{p+q}{2}$越来越接近$\sqrt{n}$。

这也就是说，对于题目中，由于p、q高350位相等，因此我们对n开根，其高位就是p+q的高位，此时测试出来仍有325位左右的低位未知，而我们从另一个信息可以得到p+q的低300位，因此爆破25位就可以找到p+q，从而得到n的分解。

exp：

```python
from Crypto.Util.number import *
from gmpy2 import *
from tqdm import *

n = 20304817598463991883487911425007927214135740826150882692657608404060781116387976327509281041677948119173928648751205240686682904704601086882134602075008186227364732648337539221512524800875230120183740426722086488143679856177002068856911689386346260227545638754513723197073169314634515297819111746527980650406024533140966706487847121511407833611739619493873042466218612052791074001203074880497201822723381092411392045694262494838335876154820241827541930328508349759776586915947972105562652406402019214248895741297737940426853122270339018032192731304168659857343755119716209856895953244774989436447915329774815874911183
e = 65537
c = 7556587235137470264699910626838724733676624636871243497222431220151475350453511634500082904961419456561498962154902587302652809217390286599510524553544201322937261018961984214725167130840149912862814078259778952625651511254849935498769610746555495241583284505893054142602024818465021302307166854509140774804110453227813731851908572434719069923423995744812007854861031927076844340649660295411912697822452943265295532645300241560020169927024244415625968273457674736848596595931178772842744480816567695738191767924194206059251669256578685972003083109038051149451286043920980235629781296629849866837148736553469654985208
leak = 1511538174156308717222440773296069138085147882345360632192251847987135518872444058511319064

#part1 factor n by Fermat's_factorization_method(adding bruteforce)
sumhigh = 2*iroot(n,2)[0] >> 325 << 325
for i in trange(2**25):
    pplusq = sumhigh + 2**300*i + leak
    if((pplusq)**2 > 4*n):
        temp = iroot((pplusq)**2-4*n,2)
        if(temp[1]):
            p_q = temp[0]
            p = (pplusq + p_q) // 2
            q = n // p
            break


#part2 get flag
phi = (p-1)*(q-1)
d = inverse(e,phi)
print(long_to_bytes(pow(c,d,n)))


#NSSCTF{JUST_@pply_Fermat's_factorization_method_W1tH_Brut3F0rce!}
```

