## easy_mod_X

+ Difficulty：Middle

## Solution

题目基于$(m,n)=(320,137)$的LWE：
$$
b = sA + e
$$
给出$A,b$，需要我们解出私钥$s$，从而解AES拿到flag。

题目奇怪的地方在于e，其每个分量都是在30个特定值中随机选择的结果，因此要做的就是搞清楚这些error奇怪在哪里。

并且实际上，这个题目和前几个mod并不像，而之所以把它放在这个系列，是因为它和前几个mod的核心方法一模一样。我们不妨回顾一下前几个mod题目的一个小操作：

+ easy_mod中，`"01234567"`变换到`(0,1,2,3,4,5,6,7)`
+ easy_mod2中，`"01234567"`变换到`(-4,-3,-2,-1,0,1,2,3)`
+ easy_mod3中，`Ns`变换到`(0,1)`
+ easy_mod_final中，`GAME`变换到`(3,1,0,-3)`

+ 再结合一下0CTF的Signin一题，在模1361下，`[0,101,731]`变换到`(-1,1,0)`

这样的变换操作目的都一样——减小目标向量的数量级，从而帮助规约。这就引来了这一个题目讨论的核心点——这个操作到底是怎么来的？我们不妨将上面的五个题目分成几类来分别思考：

+ mod和mod2很显然，由于是连续的序列，所以只需要所有值都减去一个数字就能得到更短的序列
+ mod3是二元的，可以先作差使其中一个数字变为0，之后把另一个数字乘对应的逆就得到1，就得到了目标向量01
+ 而mod_final和Signin就略微有点反直觉，虽然final中有提到这样做的本质，但是后续展开的似乎并不是很清楚

于是就诞生了这个题目——**我们需要找到一个简便的、不基于观察的方法，来确定一种直接找到这样的线性变换的思路！**

依然先基于一个事实：这种变换的本质其实是线性变换。将原来的序列记为向量$\textbf{x}$，我们变换后的目标向量$\textbf{y}$都满足：
$$
\textbf{y} = a\textbf{x} + b\cdot(1,1,...,1) \quad(mod\;p)
$$
而这种变换的目标只有一个：使$\textbf{y}$尽可能小！而要达到这样一个“找短向量”的目的，显然格就是最有力的工具，我们构造如下的格：
$$
\left(\begin{matrix}
x_1&x_2&\cdots&x_n\\
1&1&\cdots&1\\
p&&&\\
&p&&\\
&&\ddots&\\
&&&p
\end{matrix}\right)
$$
这个格具有的线性关系是：
$$
(a, b, k_1, k_2, \cdots, k_n)
\left(\begin{matrix}
x_1&x_2&\cdots&x_n\\
1&1&\cdots&1\\
p&&&\\
&p&&\\
&&\ddots&\\
&&&p
\end{matrix}\right)
=
(y_1,y_2,\cdots,y_n)
$$
对于上面的所有题目来说，这种思路都是通用的，规约后得到的向量就是我们需要的最短的目标向量$\textbf{y}$，代入反解一下就可以得到具体的a和b。

而对于本题来说也是一样，我们通过这样的格可以找到一个线性关系，使得题目中的$e$变换为：

```python
(3, 10, -8, 1, -21, 13, -26, -25, -14, 11, 19, -17, -30, 0, 24, -22, 26, 9, 12, -6, 8, -10, 15, 14, -29, 20, 23, -3, 7, 2)
```

这样的error相当小，因此只需要取150组约束就可以flatter得到结果了，给320组其实是想要顺便考一考“可以不把约束全取上来加快速度”这个小点。

而实际上，这样的error当然不是任意生成都可以线性变换得到如此短的向量的，这个题目实际error的生成过程是：

```python
x = sample(range(-30, 30), 30)
a, b = randint(0, p), randint(0, p)
e = [(i-b)*a % p for i in x]
```

所以才行:)

exp：

```python
from Crypto.Util.number import *
from Crypto.Cipher import AES
from hashlib import md5

A = 
b = 

m, n = 320, 137
A = Matrix(Zmod(p), m, n, A)
b = vector(Zmod(p), b)

from re import findall
from subprocess import check_output

def flatter(M):
    # compile https://github.com/keeganryan/flatter and put it in $PATH
    z = "[[" + "]\n[".join(" ".join(map(str, row)) for row in M) + "]]"
    ret = check_output(["flatter"], input=z.encode())
    return matrix(M.nrows(), M.ncols(), map(int, findall(b"-?\\d+", ret)))

p = 261088368789732794845261013655166647659
e = [30588206725334965124218576566361946366, 240378629906987890008899515210199268104, 73900925710927218655807121061998508862, 157139777808957554332353318136098888483, 243765215780142061395530407127372013475, 181095457676420403619327909683177178758, 168511590304599342147975740568964397279, 235779989157654444966538876611679250050, 192467270172062191434950332116042687554, 46558659970310197982201637597747473216, 62529113215285430840184698629133000066, 251750442402629677824521937643064776900, 160526363682111725718984210053271633854, 89871378955902451513790182093384035712, 137782738690828150087739365187540616262, 176496816927086958576967271084657160704, 11231167607205560879604623617803674145, 173110231053932787190336379167484415333, 113827058823365300800764773640462325987, 208437723417037424292933393147428214404, 105841832200877684371773243124769562562, 200452496794549807863941862631735450979, 54543886592797814411193168113440236641, 248363856529475506437891045725892031529, 227794762535166828537547346095986486625, 129797512068340533658747834671847852837, 70514339837773047269176229144825763491, 149154551186469937903361787620406125058, 38573433347822581553210107082054709791, 224408176662012657150916454178813741254]

x = e
L = block_matrix(ZZ, [
    [Matrix(ZZ, x)],
    [Matrix(ZZ, [1]*len(x))],
    [p]
])
res = L.LLL()[3]
k, t = Matrix(Zmod(p), L).solve_left(res)[:2]
print(res)

def primal_attack2(A,b,m,n,p):
    L = block_matrix(
        [
            [matrix(Zmod(p), A).T.echelon_form().change_ring(ZZ), 0],
            [matrix.zero(m - n, n).augment(matrix.identity(m - n) * p), 0],
            [matrix(ZZ, b), 1],
        ]
    )
    print(L.dimensions())
    L = flatter(L)
    res = L[0]
    if(res[-1] == 1):
        e2 = res[:-1]
    else:
        e2 = -res[:-1]
    return e2

nums = 150
e2 = primal_attack2((k*A)[:nums], (k*b+vector(Zmod(p), [t]*len(b)))[:nums], nums, n, p)
print(e2)

e = inverse(k,p) * (e2-vector(Zmod(p), [t]*nums))
s = A[:nums].solve_right(b[:nums]-e[:nums])
print(AES.new(key=md5(str(s).encode()).digest(), nonce=b"Tiffany", mode=AES.MODE_CTR).decrypt(bytes.fromhex("6736719094cf858ce777c0d90ab8768e6f8c9ceb43c2b2f91099a799422d376f6536f887dd8319fb16b2a6")))
```