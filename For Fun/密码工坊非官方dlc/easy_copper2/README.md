## easy_copper2

+ Difficulty：Middle

<br/>

## Solution

这个题目本来打算出给Round19，但是想了很久都没有想到一个特别好的出题方式所以暂且搁置了，最后在dlc这里展示出来。这个题目本身并不难做，主要是有一个很有意思关于爆破+copper的思路想分享出来，就做成了这个题目。

回到题目，题目内容基于RSA，要求分解由两个512bit素数相乘得到的n，为此给出如下两个额外泄露：

+ p的高230位
+ p模215656441的值

显然，只给230的p高位对于高位泄露copper来说根本不可能，一般来说未知的部分要越少越好，未知256bit已经是copper理论上的极限。同时，由于这个毕竟是理论，实际操作时不加上一些爆破的话，未知250bit已经要把epsilon取到0.01甚至更小，这会使copper速度显著减慢。

因此就要想办法利用上第二个信息，既然给了p模215656441的值，那么p的整个结构可以写为：
$$
p = p_h + 215656441x + p_l
$$
其中pl就是leak2，而leak1是将ph做了带余除法的处理，使得它是215656441的整数倍。此时x就是我们待求的小根，他的数量级大约为：
$$
\frac{2^{282}}{215656441} \approx 2^{255}
$$
所以接下来要做的事情也很好想，通过爆破一些比特位，来减小x的数量级，然后用copper把x求出来。假设我们知道了epsilon=0.01可以求解出250bit的小根(可以自己生成点数据测出来)，那么我们就要爆破2^5，大约是32次。这样已经可以解决这个题目了。

但是从现在开始才是这个题目真正想分享的东西，我们首先需要关注一下为什么选择了模215656441这么一个奇怪的数，这其实是一个提示，分解一下可以发现：

```
215656441 = 7 · 11 · 13 · 17 · 19 · 23 · 29
```

这是一些小素数的乘积，然而却没有2、3、5。这个提示的本意是：**更充分地利用上p是素数这个结构，从而用一种更优的思路去爆破。**

这是什么意思呢？观察刚才copper的多项式：
$$
p = p_h + 215656441x + p_l
$$
按常规的思路爆破bit位，无非在0-2^5内爆破i，然后把式子写成：
$$
p = p_h + 215656441(2^5x+i) + p_l
$$
正如刚才的分析，这样一共要爆破32种情况。

这种思路和我们常见的p高位泄露、p低位泄露的本质是一样的，比如如果p的高位泄露了256位，那么很自然的想法就是去爆破6位当成一个250bit的低位小根来求解。而这时其实很容易想到一个优化，那就是由于p是个素数，所以p的最低位一定是1，因此其实爆破5位就够了。

想一下这个优化的本质是什么，这个优化的本质其实是**利用p是个素数，因此p和2互素，所以能减小爆破的范围！**

那么其实仔细思考，p既然是个素数，那么p应该和所有其他素数都互素，也就是说p和3互素，p和5互素之类的信息我们其实都可以用上，来进一步减少需要爆破的范围。而缩小到的范围与原范围的比值其实就是：
$$
\frac{\phi(k)}{k}
$$
其中k是取的小素数，比如对于刚才举的用2爆破的例子，实质上就是因为phi(2)/2=1/2，从而将需要爆破的范围缩小到了原来的一半。那么既然本题中的模数21565644不含有2、3、5三个素因子，那么我们就可以考虑用如下形式的多项式去爆破+copper：
$$
p = p_h + 30*215656441x + 21565644i + p_l
$$
此时ph应该对应处理为30*215656441的倍数，由于0-30内，满足21565644i + pl与30互素的值仅有8种，所以将需要花的时间变成了原来的1/4。

exp：

```python
from Crypto.Util.number import *
from tqdm import *

num = 215656441
last = 2*3*5
bits = 282

n = 83732821313465518052403665361614770500711747426707910445616394700719876467737514967114877768176244233541342950517438107504392659632618504678367884223695674258126620001220856677629607205209582904215330731871567514530350222492246762740556482040907225061791231222448377878854527601783227627969726021295513927063
c = 46663818733755991848242947341712498383456884024793897130170411388799402223110989123025227270450872334684154450132747808192836148157068113180136519163245994436646022864578219391320904777242102617963109623497099134092899460260651347833764105572783843769863133591669278971958095602865992957181139586462882547338
leak1 = 1166802227519044965330497437183661580954600955790078699599066071608461
leak2 = 100652187

ph = (leak1 << bits) - ((leak1 << bits) % (last*num))
possible_i = []
for i in range(last):
    temp = i*num + leak2
    if(GCD(temp,last) == 1):
        possible_i.append(temp)

PR.<x> = PolynomialRing(Zmod(n))
for i in tqdm(possible_i):
    f = ph + (last*num)*x + i
    f = f.monic()
    res = f.small_roots(X = (2^bits // (last*num)) , beta=0.499,epsilon=0.01)
    if(res != []):
        p = int(ph + (last*num)*int(res[0]) +i)
        q = n // p
        m = pow(c,(inverse(65537,(p-1)*(q-1))),n)
        print(long_to_bytes(int(m)))
        break
```

同样的，这种爆破思路对普通的p高位泄露、低位泄露当然也成立，时间一般能省下3-4倍。虽然说可以省时间，但是其实开点多进程也是一样的效果，所以本来是想出成一个speedup的限时靶机题，想了想还是不太好出，最后就变成这样了。不过这个思路确实很有意思。

