## LW3

+ Difficulty：Middle
+ Solved：1

<br/>

## Description

LW:3

<br/>

## Solution

题目为如下LWE实例：
$$
\mathbf{b}_{m\times1} = A_{m\times n}\mathbf{s}_{n\times1} + \mathbf{e}_{m\times1} \quad(mod \;p)
$$
其中$(m,n)=(90,64)$，与一般的LWE不同的是，题目的$\mathbf{e}$的各分量取值仅在三个固定值中随机选择，而这三个固定值均为$GF(p)$下的随机数。

需要求解出私钥$s$，从而解AES得到flag。

#### 背景

正好趁这次题目好好讲讲LWE，因为之前[这篇](https://tangcuxiaojikuai.xyz/post/758dd33a.html)里对于LWE一些攻击的解释现在回头再看，其实不太好懂的同时也真的很麻烦。

> 主要是primal_attack的优化版本

##### LWE

我们不妨从另外一个角度来重新审视LWE——他是由如下要素组成的**特殊线性系统**：

+ $n$个$GF(p)$下的随机变量，也就是$\mathbf{s}$

+ $m$个$GF(p)$下的**有限制变量**，也就是$\mathbf{e}$

  > 这里具体是什么限制根据情况而定，比如离散高斯分布、中心二项分布以及这道题目里的三元随机采样等

  > 有时LWE也会对$\mathbf{s}$做限制，常见于各种RLWE以及MLWE等

+ $m$个由上述$m+n$个变量构成的线性等式

并且可以知道，在对$\mathbf{s}$不做任何限制的情况下，$m \le n$的情况是没有意义的，因此一般会有$m > n$。

##### primal attack

从这个角度出发的话，不做优化的primal_attack，其直观解释就是**不做任何处理，直接规约整个线性系统**，从而在规约后的短向量中找到$\mathbf{s}$以及$\mathbf{e}$，实际列出格其实也就是：
$$
L = 
\left(\begin{matrix}
I & & -A \\
  &1&\mathbf{b} \\
  & & pI \\
\end{matrix}\right)
\quad\rightarrow\quad
(\mathbf{s}, 1, *)L
=
(\mathbf{s}, 1, \mathbf{e})
$$

##### primal attack(优化版本)

而优化后的primal_attack我们知道是一种只规约出$\mathbf{e}$而不规约出$\mathbf{s}$的办法，这样做有两点好处：

+ 由于目标向量中不再出现$\mathbf{s}$，因此格可以降$n$维，提升了规约速度
+ $\mathbf{s}$本身代表$n$个$GF(p)$下的随机变量，完全不能算小量，因此对格规约基本起不到帮助，去掉他也可以排除掉这层影响

说起来简单，但是之前那篇文章介绍原理和实现的时候看上去却有些麻烦。

然而一旦切换到现在这种视角一切就很好解释的通了，整个primal attack的步骤其实就是：

+ 消元消去$n$个$\mathbf{s}$代表的变量，将原来的$m$个等式、$m+n$个变量的线性系统转化成的$m-n$个等式、$m$个变量的线性系统
+ 此时剩余的$m$个变量即为$\mathbf{e}$，因此规约这个线性系统即可

理解起来容易，实现则更简单，由于：
$$
L = 
\left(\begin{matrix}
-A \\
\mathbf{b} \\
pI \\
\end{matrix}\right)
\quad\rightarrow\quad
(\mathbf{s}, 1, *)L
=
(\mathbf{e})
$$
而对这样的$L$做个行阶梯消元并去掉零行，得到的方阵就是我们最终的格$L'$，也即primal_attack做了优化之后的攻击格。

#### 思路

依然用上述角度来审视一遍题目，现在的LWE的线性系统其实是：

+ $\mathbf{s}$代表的$n$个$GF(p)$下的随机变量
+ $\mathbf{e}$代表的$m$个$GF(p)$下的有限制变量
+ $m$个由上述$m+n$个变量构成的线性等式

特殊之处在于这里的$\mathbf{e}$的限制是已知的三个值中的随机采样。

##### 尝试

按之前的题的经验(如easy_mod，0CTF的signin，以及今年刚出的HITCON的BabyLWE等)，由于本题给出了$e$的取值范围$E$，所以或许可以找到某种线性变换，使得$E$能映射为一个新取值范围$E'$，而这个新的$E'$三个值都较小，从而利于规约。但本题的$E$是纯随机取值，所以存在线性变换使得三个值都变小的概率极小。这一点可以用如下的格的思路验证：

我们的目的是找到一个线性变换：
$$
E'=kE+t(1,1,1) \quad(mod\;p)
$$
这个线性变换：

+ $E'$较小
+ $k, t$未知

可以看出这其实就是格干的事情，较小的$E'$就是我们要规约出来的值，为此构造如下格：
$$
(k, t, r_1,r_2,r_3)
\left(\begin{matrix}
E_1&E_2&E_3\\
1&1&1\\
p\\
&p\\
&&p
\end{matrix}\right)
=
(E'_1,E'_2,E'_3)
$$
规约出来的结果其实也就是理论能找到的最短的$E'$了，代码及结果如下：

```python
L = block_matrix(ZZ, [
    [Matrix(ZZ, E)],
    [Matrix(ZZ, [1]*len(E))],
    [p]
])
E_ = L.LLL()[3]
k, t = Matrix(Zmod(p), L).solve_left(E_)[:2]
assert k*vector(GF(p), E) + t*vector(GF(p), [1,1,1]) == vector(GF(p), E_)

print(E_)
```

```python
(-298, 582, -285)
```

可以看出得到的$E'$显然不够短，规约不了，所以需要改变策略。

##### 预期

核心思想一句话就可以概括——**提升变量的个数，来缩减变量的大小**

前些天打过NSS 4th的这道[LeetSpe4k](https://tangcuxiaojikuai.xyz/post/e7cc42f8.html#more)的师傅应该多少会反应过来这样去做：将随机抽取三个值的过程，看作是未知的01向量和已知错误向量的内积，比如说对于任意一个分量$e_i$有：
$$
e_i = (x_i, y_i, z_i) \cdot 
\left(\begin{matrix}
E_1 \\
E_2 \\
E_3 \\
\end{matrix}\right)
\quad(mod\;p)
$$
其中$x_i,y_i,z_i \in \{0, 1\}$。

> 写到这去复制文章链接的才发现我完全忘记继续写那篇8月的wp总集了，有空再补上TT

这样子表示之后，整个系统显然依然是线性的，因此我们最初的LWE结构发生了改变：

+ $\mathbf{s}$代表的$n$个$GF(p)$下的随机变量
+ $\mathbf{e}$代表的$3m$个$GF(p)$下的01变量
+ $m$个由上述$3m+n$个变量构成的线性等式

而之前可能有见过以下几个题目的敏锐一点的师傅应该能察觉到一个更深的事实：

+ LilCTF的Space Travel
+ 2024 NKCTF的EZ_random
+ 甚至更早的2023 SEKAICTF的Noiser CRC

刚刚做的$x_i,y_i,z_i \in \{0, 1\}$的限制其实完全不到位，因为这几个01变量明显存在更强的限制：
$$
\quad\quad(x_i,y_i,z_i) = (1, 0, 0) \\
or \quad (x_i,y_i,z_i) = (0, 1, 0) \\
or \quad (x_i,y_i,z_i) = (0, 0, 1) 
$$
而这样的三选一的结构存在一个仿射子空间，因此可以将三维降成两维，也就是：
$$
e_i = E_1 + (x_i, y_i)\cdot
\left(\begin{matrix}
E_2-E_1 \\
E_3-E_1 \\
\end{matrix}\right)
\quad(mod\;p)
$$
此时有：
$$
\quad\quad(x_i,y_i) = (0, 0) \\
or \quad (x_i,y_i) = (0, 1) \\
or \quad (x_i,y_i) = (1, 0) 
$$
可以看出这样降维完全不改变新的变量均为01变量这一件事，因此这样操作之后LWE最终变成了：

+ $\mathbf{s}$代表的$n$个$GF(p)$下的随机变量
+ $\mathbf{e}$代表的$2m$个$GF(p)$下的01变量
+ $m$个由上述$2m+n$个变量构成的线性等式

此时我们想要应用优化后的primal attack，也就是消元将$n$个$\mathbf{s}$代表的变量消掉，就会得到最终需要的结果：**一个由$m-n$个等式、$2m$个01变量构成的线性系统**。

此时要做的事情似乎所剩不多了——构造一个$2m+1$大小的格，规约出这$2m$个01变量似乎就好，但是......

##### 优化

可以看出，通过上述方式转化后的LWE问题，我们的目标向量大小是和模数$p$完全无关的。而对于越大的$p$，我们的目标向量在格中会显得越短，求解也会越容易。

> 格中最短向量$\lambda_1(L)$和次短向量$\lambda_2(L)$的Gap越大越利于求解，这是由于格基规约算法的第一行向量的上界与实际的$\lambda_1(L)$有关

而问题出在这里，虽然本题最终的格是181维，在如此多的CTF挑战中完全不算大，但本题的$p$是20bit左右的数量级，因此Gap的差距并没有到很夸张的地步，所以求解出作为最短向量的目标向量是一个问题。为此需要做一点优化才行。

第一个优化其实老生常谈，对于规约01变量的问题，比如背包，采用$2x-1$将其映射到$1,-1$就是个很常用的优化，这样的优化本质上是做了一个类似$01$到$\frac{1}{2}, -\frac{1}{2}$的balance，因此提高了Gap，降低了求解SVP的难度。

第二个优化可能小众一点：

由于最后的问题在于约化能力，因此自然要选能求解短向量能力更强的算法，朴素一点讲的话就比如LLL求不出来就换成BKZ，BKZ做不出来就继续抬高blocksize，大多数师傅应该都这样做过。

对于这道题目来说可以用筛法或者blocksize更大的BKZ去尝试求解，打过今年高校密码挑战赛的师傅应该会听说blaster这样一个黑科技，虽然他需要格的entry比较小(小于32bit或者64bit，似乎取决于具体的机器数)，但是在符合要求的情况下可以很快地实现blocksize较大的BKZ算法，而本题最终可以用blaster求解，在个人电脑跑的话大概五六分钟左右。